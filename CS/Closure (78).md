# 클로저

<br>

클로저란 렉시컬 스코프의 응용이다.

<br>

## 😀 렉시컬 스코프?

자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라

함수를 어디서 정의했는지에 따라서 상위 스코프를 결정한다.

<br>

이것을 렉시컬 스코프 또는 정적 스코프 라고한다.

<br>

## 내부슬롯 [[Environment]]

<br>

함수자신이 정의 되었을 시점때 렉시컬 환경에 의해서

내부슬롯 [[Environment]]에 자신이 정의된 환경인 상위스코프를 저장한다.

<br>

이 내부슬롯 [[Environment]]에 저장되어진 상위스코프는 함수 자신이 호출되었을때 생성되어질 실행컨텍스트의 렉시컬환경의 외부 환경에 대한 참조에 저장될 참조값이 되어진다.

<br>

## 외부함수, 내부함수

<br>

내부함수가 존재하는한 [[Environment]]에 저장되어지는 상위스코프는 계속 유지 되어진다.

<br>

외부함수의 실행이 종료가 되어진다고 하더라도

외부 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만

외부 함수의 렉시컬 환경까지 소멸하는 것은 아니다.

<br>

따라서 내부함수가 외부함수보다 더 오래 생명주기가 유지되어질 경우,

외부함수의 밖에서 내부함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있다.

<br>

이러한 함수를 **클로저**라고 부른다.

<br>

## 😛 그렇다면 모든 함수는 상위 스코프를 기억하므로 모든 함수는 클로저 일까?

<br>

자바스크립트에서 모든 함수는 상위 스코프를 기억하므로 이론적으로는 모든 함수는 클로저이다.

<br>

하지만!

<br>

### 1. 내부함수가 외부함수보다 더 오래 유지되지만 상위스코프의 어떠한 식별자도 참조 하지 않는다면

<br>

크롬 브라우저 디버깅 모드에서도 상위 스코프의 식별자를 참조하지 않아 상위스코프를 기억하는것은 메모리 낭비이기 때문에 클로저라고 표시되지 않는다.

<br>

따라서 이때는 클로저라고 할 수 없다.

<br>

### 2. 외부함수의 외부로 내부함수가 반환되지 않는다면

<br>

외부함수가 내부함수보다 생명주기가 더짧다면 내부함수는 클로저였지만

외부함수보다 더 일찍 소멸되기 때문에 클로저라고 하지 않는다.

<br>

### 3. 외부 함수보다 내부함수가 더 오래 유지되고 상위 스코프의 식별자를 참조한다면

<br>

클로저는 내부함수가 상위스코프의 식별자를 참조하고 있고 내부함수가 외부함수보다 더 유지 되는 경우에 한정하는 것을 일반적으로 클로저라고 한다.

<br>

### 🧐 팁!

브라우저에서는 내부함수가 상위스코프의 식별자를 참조하는것이 일부분이고 모든 상위스코프를 기억해야하므로 메모리 낭비이다.

<br>

따라서 모던 자바스크립트는 클로저가 식별하고 있는 상위 스코프의 변수만을 기억하는 최적화를 한다.

<br>

이때 이 변수를 **자유 변수(free variable)**이라고 한다.

<br>

## 😮 그렇다면 클로저는 언제 사용할까?

<br>

### 스코프 체인

<br>

자바스크립트 엔진은 렉시컬 환경에 의해 상위 스코프를 기억한다.

이때 식별자를 검색할때 항상 하위 스코프에서 상위 스코프 방향으로만 검색이 된다.

<br>

따라서 상위에서 하위로 방향은 식별자를 검색할 수 없다.

<br>

이러한 특성을 이용한 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

<br>

**의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.**

<br>

예제코드)

```jsx
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

<br>

상태 num은 increase에 의해서만 변경 되어져야 한다.

하지만 전역 변수라서 누구든지 접근할 수 있다.

<br>

예제코드)

```jsx
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    // 카운트 상태를 1만큼 증가 시킨다.
    return ++num;
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

<br>

다음과 같이 외부함수를 호출했을때 반환값으로 내부함수를 즉시실행함수로 실행시키게 하여 상태를 오로지 increase가 호출될때마다 변경되어진다.

<br>

### 정리

<br>

- 렉시컬 스코프로 응용

  ⇒ 내부슬롯 [[Environment]] 상위스코프 참조 저장

- 외부함수, 내부함수
- 클로저의 활용

  ⇒ 클로저는 상태를 안전하게 변경,유지 목적(상태 은닉) / 특정 함수에게만 상태 변경 허용

  ⇒ 의도치 않게 변경되지 않도록 은닉

<br>

참고

- [책 모던 자바스크립트 딥 다이브](http://www.yes24.com/Product/Goods/92742567)